1: Describe an analogy for relating an algorithm that has efficiency O(1) and another algorithm that has O(2n)

   O(1) is like an empty self-service check-out line compared to O(2n) that is like a Costco clerk check-out line 20 people deep.  Damn those lines! lol

2: In plain English, what is the best case scenario for binary search?

  The item to be found is the first one after divide and conquering.

3: In plain English, what is the worst-case scenario for binary search?

  The item to be found is the last one after divide and conquering.

4: In plain English, what is the bounded-case scenario for binary search?

  The item to be found is somewhere near the middle of the first item to be found or the last.  It will be slower then best-case, but faster then worse-case.

5: Create a graph using the data below. Here's a CSV with the values you'll need.
{0,1},
{1,2},
{2,4},
{3,8},
{4,16},
{5,32},
{6,64},
{7,128},
{8,256},
{9,512},
{10,1024}

5.1: What's the asymptotic limit as n approaches infinity for the function defined by the values above?

  There is no limit

5.2: What is the Big-O of an algorithm that has the data points above?

  O(2^n)

6: Write a Ruby script that calculates and prints the input size to iterations for the worst-case similar to the graph above for linear search.

  May be reading this question wrong?

  ```def function(array)
      array.each do |i|
        x = i
        puts "{#{x}, #{2**x}}"
      end
    end```

7: Create a graph from the output using Google Sheets or other graphing software. Analyze the graph and denote its Big-O somewhere on the graph.

7.1: What is the Big-O of binary search?

  O(log n)

7.2: What is the Big-Ω of binary search?

  Ω(1) which means first result

7.3: What is the Big-Ө of binary search?

  O(log n) half way?
