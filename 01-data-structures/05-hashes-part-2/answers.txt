Describe three collision resolution strategies not mentioned here.
• "Robin Hood Hashing" - The idea is that a new key may displace a key already inserted, if its probe count is larger than that of the key at the current position. The net effect of this is that it reduces worst case search times in the table. This is similar to ordered hash tables except that the criterion for bumping a key does not depend on a direct relationship between the keys. Since both the worst case and the variation in the number of probes is reduced dramatically, an interesting variation is to probe the table starting at the expected successful probe value and then expand from that position in both directions. External Robin Hood hashing is an extension of this algorithm where the table is stored in an external file and each table position corresponds to a fixed-sized page or bucket with B records.(https://en.wikipedia.org/wiki/Hash_table#Robin_Hood_hashing)
• "2-Choice Hashing" - uses two different hash functions, h1(x) and h2(x), for the hash table. Both hash functions are used to compute two table locations. When an object is inserted in the table, then it is placed in the table location that contains fewer objects (with the default being the h1(x) table location if there is equality in bucket size). 2-choice hashing employs the principle of the power of two choices. (https://en.wikipedia.org/wiki/Hash_table#2-choice_hashing)
• "Random Hashing" - Use a random number generator to set the index based on key and if a collision occurs, generate another random number and continue to do so until no further collisions occur. (http://cseweb.ucsd.edu/~kube/cls/100/Lectures/lec16/lec16-24.html)

Create your own collision resolution strategy and describe how it works.
One idea would be to interpret the first five characters into an ASCII code and sum the values and setting the sum as an index. I'm thinking this might result in higher probability of a unique index. Don't think this would be true for small arrays though.
